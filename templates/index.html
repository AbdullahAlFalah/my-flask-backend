<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Abdullah's Flask App</title>
    <style>
        body { 
            margin: 0; 
            background: black; 
            overflow: hidden;
            font-family: 'Press Start 2P', monospace; /* pixel font */
            color: #fff;
            text-align: center;
        }
        h1, p {
            position: absolute;
            width: 100%;
            z-index: 10;
            text-shadow: 0 0 8px rgb(247, 0, 255), 0 0 16px rgb(247, 0, 255); /* purple glow */
        }
        h1 {
            top: 40px;
            font-size: 24px;
        }
        p {
            top: 80px;
            font-size: 14px;
        }
        #score {
            position: absolute;
            top: 20px;
            right: 30px;
            font-size: 14px;
            z-index: 10;
            color: #fff;
            text-shadow: 0 0 8px #ff0, 0 0 16px #ff0; /* yellow glow */
        }
        #musicControl {
            position: absolute;
            top: 20px;
            left: 30px;
            font-size: 12px;
            z-index: 10;
            color: #fff;
            text-shadow: 0 0 8px #0f0, 0 0 16px #0f0; /* green glow */
            cursor: pointer;
            user-select: none;
        }
        canvas { 
            display: block; 
            margin: auto; 
            image-rendering: pixelated;
            background: black;
        }
    </style>
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
    <!-- Google Pixel Font -->
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
</head>
<body>
    <h1>Hello from Flask!</h1>
    <p>This is the landing page of your Flask backend project</p>

    <!-- Score counter -->
    <div id="score">Coins: 0</div>

    <!-- Music control -->
    <div id="musicControl">ðŸ”Š Music: ON (Click to toggle)</div>

    <canvas id="game" width="800" height="600"></canvas>

    <script>
        const canvas = document.getElementById("game");
        const ctx = canvas.getContext("2d");
        const scoreDisplay = document.getElementById("score");
        const musicControl = document.getElementById("musicControl");

        // Make sure these match your groundTile.png dimensions
        const TILE_WIDTH = 64; 
        const TILE_HEIGHT = 64;

        let gameState = {
            GROUND_Y: 0,
            coins: [],
            score: 0
        };

        // Background music setup (optional - won't block page load)
        let bgMusic = new Audio;
        let musicEnabled = false;
        let musicLoaded = false;

        if (musicControl) {
            bgMusic.src = "/static/music.mp3";
            bgMusic.loop = true;
            bgMusic.volume = 0.3;

            // Check if music file exists
            bgMusic.addEventListener('canplaythrough', () => {
                musicLoaded = true;
                musicControl.textContent = "ðŸ”Š Music: OFF (Click to play)";
                console.log("Music loaded successfully");
            });

            bgMusic.addEventListener('error', () => {
                musicControl.textContent = "ðŸ”‡ No music file";
                musicControl.style.opacity = "0.5";
                musicControl.style.cursor = "default";
                console.log("Music file not found - game will work without it");
            });

            musicControl.addEventListener("click", () => {
                if (!musicLoaded) return;
                
                musicEnabled = !musicEnabled;
                if (musicEnabled) {
                    bgMusic.play().catch(e => console.log("Audio play failed:", e));
                    musicControl.textContent = "ðŸ”Š Music: ON (Click to toggle)";
                } else {
                    bgMusic.pause();
                    musicControl.textContent = "ðŸ”‡ Music: OFF (Click to play)";
                }
            });
        }

        let musicStarted = false;
        function tryStartMusic() {
            if (!musicStarted && musicEnabled && musicLoaded && bgMusic) {
                bgMusic.play().catch(e => console.log("Audio play failed:", e));
                musicStarted = true;
            }
        }
        document.addEventListener("keydown", tryStartMusic, { once: true });
        canvas.addEventListener("click", tryStartMusic, { once: true });

        // Make canvas responsive
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gameState.GROUND_Y = canvas.height - TILE_HEIGHT; // ground level
        }
        window.addEventListener("resize", resizeCanvas);
        resizeCanvas(); // Initial call to set size and GROUND_Y

        // Load sprites
        const bgImg = new Image();
        bgImg.src = "/static/Background.png";

        const groundTile = new Image();
        groundTile.src = "/static/Groundtile.png";

        const coinImg = new Image();
        coinImg.src = "/static/Coin.png";

        const animations = {
            idle: { img: new Image(), frames: 4 },
            walk: { img: new Image(), frames: 8 },
            run:  { img: new Image(), frames: 7 },
            jump: { img: new Image(), frames: 6 }
        };

        animations.idle.img.src = "/static/IdlePlayer.png";
        animations.walk.img.src = "/static/Walk.png";
        animations.run.img.src = "/static/Run.png";
        animations.jump.img.src = "/static/Jump.png";

        // Player setup
        let player = { 
            x: 50, 
            y: gameState.GROUND_Y - 128, // start above ground 
            w: 128, 
            h: 128,
            cw: 0,   // collision width
            ch: 0,   // collision height
            cxOff: 0, // x offset to center hitbox
            cyOff: 0, // y offset to raise hitbox
            dy: 0, 
            vx: 0, // horizontal velocity
            accel: 0, // how quickly to reach target speed (lower = smoother)
            maxSpeed: 0, // walking speed
            runMultiplier: 0, // running boost
            friction: 0, // slows player when no key is pressed
            isRunning: false, 
            jumping: false, 
            facing: 1,
            frame: 0,
            frameTimer: 0,
            frameInterval: 10,
            currentAnim: "idle",
            debugW: 0,
            debugH: 0,
            debugX: 0,
            debugY: 0
        };

        // Key state tracker
        let keys = {};

        // Key listeners for movement
        document.addEventListener("keydown", e => {
            keys[e.code] = true;
            if (e.code === "Space" && !player.jumping) {
                player.dy = -15;
                player.jumping = true;
            }
            if (e.code === "ShiftLeft" || e.code === "ShiftRight") { 
                player.isRunning = true;
            }
        });

        document.addEventListener("keyup", e => {
            keys[e.code] = false;
            if (e.code === "ShiftLeft" || e.code === "ShiftRight") {
                player.isRunning = false;
            }
        });

        // Spawn coins
        function spawnCoin() {
            let x = Math.random() * (canvas.width - 32);
            // Coins will spawn between 50 pixels and 150 pixels above the ground line.
            const MIN_Y_OFFSET = 150; 
            const MAX_Y_OFFSET = 50; 
            let randomOffset = Math.random() * (MIN_Y_OFFSET - MAX_Y_OFFSET) + MAX_Y_OFFSET;
            let y = gameState.GROUND_Y - randomOffset;
            // Adjusted: Position coin 50px above the ground
            gameState.coins.push({ x, y, w: 32, h: 32 });
        }
        setInterval(spawnCoin, 5000);

        // Coin rotation
        let coinAngle = 0;
        function updateCoinRotation() {
            coinAngle += 0.05; // rotation speed
        }

        function drawCoin(c, angle) {
            ctx.save();
            ctx.translate(c.x + c.w/2, c.y + c.h/2);
            ctx.rotate(angle);
            ctx.drawImage(coinImg, -c.w/2, -c.h/2, c.w, c.h);
            ctx.restore();
        }

        function updatePlayerAnimation() {
            if (player.jumping) {
                player.currentAnim = "jump";
            } else if (keys["ArrowLeft"] || keys["ArrowRight"]) {
                player.currentAnim = player.isRunning ? "run" : "walk";
            } else {
                player.currentAnim = "idle";
            }

            let anim = animations[player.currentAnim];
            if (!anim.img.complete) return; // Wait for image to load
            // Frame stepping
            player.frameTimer++;
            if (player.frameTimer > player.frameInterval) {
                player.frame = (player.frame + 1) % anim.frames; // Loop animation
                player.frameTimer = 0;
            }
        }

        // Draw ground tiles
        function drawGround() {
            for (let x = 0; x < canvas.width; x += TILE_WIDTH) {
                ctx.drawImage(groundTile, x, gameState.GROUND_Y, TILE_WIDTH, TILE_HEIGHT);
            }
        }

        // Define relative size of hitbox (percent of sprite)
        const hitboxWidthRatio = 0.3;  // 30% of sprite width
        const hitboxHeightRatio = 0.5; // 50% of sprite height

        // Set player variables: hitbox relative to sprite
        player.cw = player.w * 0.3; // Setting collision width for player object
        player.ch = player.h * 0.5; // Setting collision height for player object
        player.cxOff = (player.w - player.cw) / 6;  // Center horizontally
        player.cyOff = player.h - player.ch;  // Start hitbox at ground/feet level

        // Debug box dimensions (optional, just mirrors actual box's dimensions)
        player.debugW = player.cw;
        player.debugH = player.ch;

        // Player collision box fully defined
        // Rerurns px, py = top-left corner coordinates of the player's collision box
        const pw = player.cw;
        const ph = player.ch;
        function getPlayerCollisionBox() {
            const px = player.facing === 1
                ? player.x + player.cxOff // Facing right
                : player.x + (player.w - player.cxOff - player.cw); // Adjust if facing left
            const py = player.y + player.cyOff;

            return { px: px, py: py };
        }

        // Draw player sprite
        function drawPlayer() {
            let anim = animations[player.currentAnim];
            if (!anim.img.complete) return;

            // Auto-calculate frame dimensions
            let frameW = anim.img.width / anim.frames;
            let frameH = anim.img.height;

            // Pick slice based on current frame
            let sx = player.frame * frameW;

            // FIXED: Use consistent drawing method that doesn't cause position shifts
            ctx.save();

            // When facing left, translate to the RIGHT edge of the sprite
            // then flip, so the sprite stays in the same world position
            if (player.facing === -1) {
                ctx.translate(player.x + player.w, player.y);
                ctx.scale(-1, 1);
                ctx.drawImage(
                    anim.img,
                    sx, 0, frameW, frameH,
                    0, 0,
                    player.w, player.h
                );
            } else {
                ctx.translate(player.x, player.y);
                ctx.drawImage(
                    anim.img,
                    sx, 0, frameW, frameH,
                    0, 0,
                    player.w, player.h
                );
            }

            ctx.restore();

            const { px, py } = getPlayerCollisionBox();
            // Update debug box position to match player collision box
            player.debugX = px;
            player.debugY = py;

            // Debug hitbox - purely for visualization
            ctx.strokeStyle = "red";
            ctx.lineWidth = 1;
            ctx.strokeRect(
                player.debugX,
                player.debugY,
                player.debugW,
                player.debugH
            ); 
        }

        // Add velocity and movement tuning to player
        player.vx = 0;
        player.accel = 0.2;
        player.maxSpeed = 4;   
        player.runMultiplier = 1.8;
        player.friction = 0.1;

        // Game loop logic
        function update() {
            // Gravity: Use the consistent GROUND_Y value for collision
            player.dy += 1;
            player.y += player.dy;
            if (player.y >= gameState.GROUND_Y - player.h) {
                // Snap player position exactly to the ground
                player.y = gameState.GROUND_Y - player.h;
                player.dy = 0;
                player.jumping = false;
            }
            
            // ---- Smooth Movement ----
            let targetSpeed = 0;
            if (keys["ArrowLeft"]) targetSpeed = -player.maxSpeed;
            if (keys["ArrowRight"]) targetSpeed = player.maxSpeed;

            // Apply running multiplier
            if (player.isRunning) targetSpeed *= player.runMultiplier;

            // Accelerate towards target speed
            player.vx += (targetSpeed - player.vx) * player.accel;

            // Apply friction if no key pressed
            if (!keys["ArrowLeft"] && !keys["ArrowRight"]) {
                player.vx *= (1 - player.friction);
            }

            // Update player position
            player.x += player.vx;

            // Update facing depending on velocity
            if (player.vx > 0.1) player.facing = 1;
            if (player.vx < -0.1) player.facing = -1;

            const { px, py } = getPlayerCollisionBox();

            // Prevent going off screen
            if (px < 0) {
                player.x -= px;  // Look right so box aligns with 0
                player.vx = 0;
            }
            if (px + pw > canvas.width) {
                player.x -= (px + pw - canvas.width); // Look left
                player.vx = 0;
            }

            // Check for coin collection using player's collision box
            gameState.coins = gameState.coins.filter(c => {
                // Coin collision box
                const cx = c.x;
                const cy = c.y;
                const cw = c.w;
                const ch = c.h;

                // Check overlap
                let hit = 
                    px < cx + cw &&
                    px + pw > cx &&
                    py < cy + ch &&
                    py + ph > cy;

                if (hit) {
                    gameState.score++;
                    scoreDisplay.textContent = "Coins: " + gameState.score;
                }
                return !hit; // remove if collected
            });

            // Update coin rotation
            updateCoinRotation();
            // Update player animation
            updatePlayerAnimation();
        }

        function draw() {
            // background
            ctx.drawImage(bgImg, 0, 0, canvas.width, canvas.height);

            // ground tiles
            drawGround();

            // player
            drawPlayer();

            // coins
            gameState.coins.forEach(c => drawCoin(c, coinAngle));
        }

        function loop() {
            update();
            draw();
            requestAnimationFrame(loop);
        }

        // Wait for ALL images to load before starting the loop
        const allAssets = [
            bgImg, 
            groundTile, 
            coinImg,
            animations.idle.img,
            animations.walk.img,
            animations.run.img,
            animations.jump.img 
        ];
        let assetsLoaded = 0;

        allAssets.forEach(img => {
            img.onload = () => {
                assetsLoaded++;
                if (assetsLoaded === allAssets.length) {
                    console.log("All assets loaded. Starting game loop.");
                    loop(); // Start the game loop only after all images are ready
                }
            };
            img.onerror = () => {
                console.error(`Failed to load asset: ${img.src}`);
            };
        });

    </script>

</body>
</html>
