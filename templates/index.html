<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Abdullah's Flask App</title>
    <style>
        body { 
            margin: 0; 
            background: black; 
            overflow: hidden;
            font-family: 'Press Start 2P', monospace; /* pixel font */
            color: #fff;
            text-align: center;
        }
        h1, p {
            position: absolute;
            width: 100%;
            z-index: 10;
            text-shadow: 0 0 8px #0ff, 0 0 16px #0ff; /* glowing light effect */
        }
        h1 {
            top: 40px;
            font-size: 24px;
        }
        p {
            top: 80px;
            font-size: 14px;
        }
        #score {
            position: absolute;
            top: 20px;
            right: 30px;
            font-size: 14px;
            z-index: 10;
            color: #fff;
            text-shadow: 0 0 8px #ff0, 0 0 16px #ff0; /* yellow glow */
        }
        canvas { 
            display: block; 
            margin: auto; 
            image-rendering: pixelated;
            background: black;
        }
    </style>
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
    <!-- Google Pixel Font -->
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
</head>
<body>
    <h1>Hello from Flask!</h1>
    <p>This is the landing page of your Flask backend project</p>

    <!-- Score counter -->
    <div id="score">Coins: 0</div>

    <canvas id="game" width="800" height="600"></canvas>

    <script>
        const canvas = document.getElementById("game");
        const ctx = canvas.getContext("2d");
        const scoreDisplay = document.getElementById("score");

        // Make sure these match your groundTile.png dimensions
        const TILE_WIDTH = 64; 
        const TILE_HEIGHT = 64;

        let gameState = {
            GROUND_Y: 0,
            coins: [],
            score: 0
        };

        // Make canvas responsive
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gameState.GROUND_Y = canvas.height - TILE_HEIGHT; // ground level
        }
        window.addEventListener("resize", resizeCanvas);
        resizeCanvas(); // Initial call to set size and GROUND_Y

        // Load sprites
        const bgImg = new Image();
        bgImg.src = "/static/Background.png";

        const groundTile = new Image();
        groundTile.src = "/static/Groundtile.png";

        const coinImg = new Image();
        coinImg.src = "/static/Coin.png";

        const animations = {
            idle: { img: new Image(), frames: 4 },
            walk: { img: new Image(), frames: 8 },
            run:  { img: new Image(), frames: 7 },
            jump: { img: new Image(), frames: 6 }
        };

        animations.idle.img.src = "/static/Idleplayer.png";
        animations.walk.img.src = "/static/Walk.png";
        animations.run.img.src = "/static/Run.png";
        animations.jump.img.src = "/static/Jump.png";

        // Player setup
        let player = { 
            x: 50, 
            y: gameState.GROUND_Y - 128, // start above ground 
            w: 128, 
            h: 128,
            cw: 0,   // collision width
            ch: 0,   // collision height
            cxOff: 0, // x offset to center hitbox
            cyOff: 0, // y offset to raise hitbox
            dy: 0, 
            speed: 5,
            isRunning: false, 
            jumping: false, 
            facing: 1,
            frame: 0,
            frameTimer: 0,
            frameInterval: 10,
            currentAnim: "idle",
            debugW: 0,
            debugH: 0,
            debugX: 0,
            debugY: 0
        };

        // Key state tracker
        let keys = {};

        // Key listeners for movement
        document.addEventListener("keydown", e => {
            keys[e.code] = true;
            if (e.code === "Space" && !player.jumping) {
                player.dy = -15;
                player.jumping = true;
            }
            if (e.code === "ShiftLeft" || e.code === "ShiftRight") { 
                player.isRunning = true;
            }
        });

        document.addEventListener("keyup", e => {
            keys[e.code] = false;
            if (e.code === "ShiftLeft" || e.code === "ShiftRight") {
                player.isRunning = false;
            }
        });

        // Spawn coins
        function spawnCoin() {
            let x = Math.random() * (canvas.width - 32);
            // Coins will spawn between 50 pixels and 150 pixels above the ground line.
            const MIN_Y_OFFSET = 150; 
            const MAX_Y_OFFSET = 50; 
            let randomOffset = Math.random() * (MIN_Y_OFFSET - MAX_Y_OFFSET) + MAX_Y_OFFSET;
            let y = gameState.GROUND_Y - randomOffset;
            // Adjusted: Position coin 50px above the ground
            gameState.coins.push({ x, y, w: 32, h: 32 });
        }
        setInterval(spawnCoin, 5000);

        // Coin rotation
        let coinAngle = 0;
        function updateCoinRotation() {
            coinAngle += 0.05; // rotation speed
        }

        function drawCoin(c, angle) {
            ctx.save();
            ctx.translate(c.x + c.w/2, c.y + c.h/2);
            ctx.rotate(angle);
            ctx.drawImage(coinImg, -c.w/2, -c.h/2, c.w, c.h);
            ctx.restore();
        }

        function updatePlayerAnimation() {
            if (player.jumping) {
                player.currentAnim = "jump";
            } else if (keys["ArrowLeft"] || keys["ArrowRight"]) {
                player.currentAnim = player.isRunning ? "run" : "walk";
            } else {
                player.currentAnim = "idle";
            }

            let anim = animations[player.currentAnim];
            if (!anim.img.complete) return; // Wait for image to load
            // Frame stepping
            player.frameTimer++;
            if (player.frameTimer > player.frameInterval) {
                player.frame = (player.frame + 1) % anim.frames; // Loop animation
                player.frameTimer = 0;
            }
        }

        // Draw ground tiles
        function drawGround() {
            for (let x = 0; x < canvas.width; x += TILE_WIDTH) {
                ctx.drawImage(groundTile, x, gameState.GROUND_Y, TILE_WIDTH, TILE_HEIGHT);
            }
        }

        // Define relative size of hitbox (percent of sprite)
        const hitboxWidthRatio = 0.3;  // 30% of sprite width
        const hitboxHeightRatio = 0.5; // 50% of sprite height

        // Set player variables: hitbox relative to sprite
        player.cw = player.w * 0.3; // Setting collision width for player object
        player.ch = player.h * 0.5; // Setting collision height for player object
        player.cxOff = (player.w - player.cw) / 6;  // Center horizontally
        player.cyOff = player.h - player.ch;  // Start hitbox at ground/feet level

        // Debug box dimensions (optional, just mirrors actual box's dimensions)
        player.debugW = player.cw;
        player.debugH = player.ch;

        // Player collision box fully defined
        // Rerurns px, py = top-left corner coordinates of the player's collision box
        const pw = player.cw;
        const ph = player.ch;
        function getPlayerCollisionBox() {
            const px = player.facing === 1
                ? player.x + player.cxOff // Facing right
                : player.x + (player.w - player.cxOff - player.cw); // Adjust if facing left
            const py = player.y + player.cyOff;
            return { px: px, py: py };
        }

        // Draw player sprite
        function drawPlayer() {
            let anim = animations[player.currentAnim];
            if (!anim.img.complete) return;

            // Auto-calculate frame dimensions
            let frameW = anim.img.width / anim.frames;
            let frameH = anim.img.height;

            // Pick slice based on current frame
            let sx = player.frame * frameW;

            // Draw with facing direction: Mirror if facing left
            ctx.save();
            ctx.translate(player.x + player.w / 2, player.y + player.h / 2);
            ctx.scale(player.facing, 1); // Flip horizontally if facing left
            ctx.drawImage(
                anim.img,
                sx, 0, (frameW), (frameH), // Source rectangle
                -player.w / 2, -player.h / 2, // Draw centered
                player.w, player.h            // Destination size
            );
            ctx.restore();

            const { px, py } = getPlayerCollisionBox();
            // Update debug box position to match player collision box
            player.debugX = px;
            player.debugY = py;

            // Debug hitbox - purely for visualization
            ctx.strokeStyle = "red";
            ctx.lineWidth = 1;
            ctx.strokeRect(
                player.debugX,
                player.debugY,
                player.debugW,
                player.debugH
            );
        }

        // Game loop logic
        function update() {
            // Gravity: Use the consistent GROUND_Y value for collision
            player.dy += 1;
            player.y += player.dy;
            if (player.y >= gameState.GROUND_Y - player.h) {
                // Snap player position exactly to the ground
                player.y = gameState.GROUND_Y - player.h;
                player.dy = 0;
                player.jumping = false;
            }
            
            // Move left/right
            let speed = player.speed * (player.isRunning ? 2 : 1);
            if (keys["ArrowLeft"]) {
                player.x -= speed;
                player.facing = -1;
            }
            if (keys["ArrowRight"]) {
                player.x += speed;
                player.facing = 1;
            }

            const { px, py } = getPlayerCollisionBox();

            // Prevent going off screen
            if (px < 0) {
                player.x = player.facing === 1
                    ? 0 - player.cxOff // Keep left edge inside
                    : 0 - (player.w - player.cxOff - pw); // Adjust if facing left 
            }
            if (px + pw > canvas.width) {
                player.x = player.facing === 1
                    ? canvas.width - player.cxOff - pw // Keep right edge inside
                    : canvas.width - (player.w - player.cxOff); // Adjust if facing right
            }

            // Check for coin collection using player's collision box
            gameState.coins = gameState.coins.filter(c => {
                // Coin collision box
                const cx = c.x;
                const cy = c.y;
                const cw = c.w;
                const ch = c.h;

                // Check overlap
                let hit = 
                    px < cx + cw &&
                    px + pw > cx &&
                    py < cy + ch &&
                    py + ph > cy;

                if (hit) {
                    gameState.score++;
                    scoreDisplay.textContent = "Coins: " + gameState.score;
                }
                return !hit; // remove if collected
            });

            // Update coin rotation
            updateCoinRotation();
            // Update player animation
            updatePlayerAnimation();
        }

        function draw() {
            // background
            ctx.drawImage(bgImg, 0, 0, canvas.width, canvas.height);

            // ground tiles
            drawGround();

            // player
            drawPlayer();

            // coins
            gameState.coins.forEach(c => drawCoin(c, coinAngle));
        }

        function loop() {
            update();
            draw();
            requestAnimationFrame(loop);
        }

        // Wait for ALL images to load before starting the loop
        const allAssets = [
            bgImg, 
            groundTile, 
            coinImg,
            animations.idle.img,
            animations.walk.img,
            animations.run.img,
            animations.jump.img 
        ];
        let assetsLoaded = 0;

        allAssets.forEach(img => {
            img.onload = () => {
                assetsLoaded++;
                if (assetsLoaded === allAssets.length) {
                    console.log("All assets loaded. Starting game loop.");
                    loop(); // Start the game loop only after all images are ready
                }
            };
            img.onerror = () => {
                console.error(`Failed to load asset: ${img.src}`);
            };
        });

    </script>

</body>
</html>
